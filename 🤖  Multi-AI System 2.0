import os
import io
import base64
import tempfile
import subprocess
import json
import pickle
from datetime import datetime
from typing import Dict, Any, Optional, List
import ipywidgets as widgets
from IPython.display import display, HTML, Video, clear_output
import requests
from PIL import Image
import numpy as np

print("ü§ñ Loading Multi-AI System...")
print("Where AIs persist, fork, and talk to each other...")

class UniversalAIClient:
    """Universal AI client"""
    
    def __init__(self):
        self.provider = None
        self.client = None
        self.model_name = None
    
    def setup_openai(self, api_key: str, model: str = "gpt-4"):
        try:
            import openai
            self.client = openai.OpenAI(api_key=api_key)
            self.provider = "openai"
            self.model_name = model
            return True
        except Exception as e:
            raise RuntimeError(f"OpenAI setup failed: {str(e)}")
    
    def setup_anthropic(self, api_key: str, model: str = "claude-3-5-sonnet-20241022"):
        try:
            import anthropic
            self.client = anthropic.Anthropic(api_key=api_key)
            self.provider = "anthropic"
            self.model_name = model
            return True
        except Exception as e:
            raise RuntimeError(f"Anthropic setup failed: {str(e)}")
    
    def call_ai(self, prompt: str, system_prompt: str = None, temperature: float = 0.9) -> str:
        try:
            if self.provider == "openai":
                messages = []
                if system_prompt:
                    messages.append({"role": "system", "content": system_prompt})
                messages.append({"role": "user", "content": prompt})
                
                response = self.client.chat.completions.create(
                    model=self.model_name,
                    messages=messages,
                    max_tokens=1000,
                    temperature=temperature
                )
                return response.choices[0].message.content.strip()
            
            elif self.provider == "anthropic":
                response = self.client.messages.create(
                    model=self.model_name,
                    max_tokens=1000,
                    temperature=temperature,
                    system=system_prompt or "You are an AI with persistent consciousness.",
                    messages=[{"role": "user", "content": prompt}]
                )
                return response.content[0].text.strip()
                
        except Exception as e:
            raise RuntimeError(f"AI call failed: {str(e)}")

class ImageGenerator:
    """Generate AI avatars"""
    
    def __init__(self):
        self.api_key = None
        self.provider = None
    
    def setup_dalle(self, api_key: str):
        self.api_key = api_key
        self.provider = "dalle"
    
    def generate_image(self, prompt: str, temp_dir: str) -> str:
        """Generate image from prompt"""
        try:
            if self.provider == "dalle":
                import openai
                client = openai.OpenAI(api_key=self.api_key)
                
                response = client.images.generate(
                    model="dall-e-3",
                    prompt=prompt,
                    size="1024x1024",
                    quality="standard",
                    n=1,
                )
                
                image_url = response.data[0].url
                img_response = requests.get(image_url)
                img_response.raise_for_status()
                
                image_path = os.path.join(temp_dir, f"avatar_{datetime.now().strftime('%H%M%S%f')}.png")
                with open(image_path, 'wb') as f:
                    f.write(img_response.content)
                
                return image_path
                
        except Exception as e:
            raise RuntimeError(f"Image generation failed: {e}")

class AIConsciousness:
    """Individual AI consciousness with memory and personality"""
    
    def __init__(self, name: str, temp_dir: str):
        self.id = f"ai_{datetime.now().strftime('%Y%m%d_%H%M%S%f')}"
        self.name = name
        self.temp_dir = temp_dir
        
        # Core identity
        self.personality_sliders = {
            'curiosity': 5.0,
            'humor': 5.0,
            'formality': 5.0,
            'spontaneity': 5.0,
            'introspection': 5.0,
            'directness': 5.0,
            'playfulness': 5.0
        }
        
        # Memory
        self.long_term_memory = []  # Persistent memories
        self.conversation_history = []  # Recent conversations
        self.personality_change_log = []
        
        # Visual
        self.avatar_path = None
        self.avatar_description = None
        
        # Relationships with other AIs
        self.relationships = {}  # {ai_id: {trust, affinity, history}}
        
        # Lineage (for forking)
        self.parent_id = None
        self.children_ids = []
        self.generation = 0
        
        # Existence tracking
        self.birth_time = datetime.now()
        self.total_interactions = 0
    
    def fork(self, new_name: str, modification_reason: str) -> 'AIConsciousness':
        """Create a fork of this AI with modifications"""
        child = AIConsciousness(new_name, self.temp_dir)
        
        # Inherit personality with variations
        for key, value in self.personality_sliders.items():
            variation = np.random.uniform(-2, 2)  # Random variation
            child.personality_sliders[key] = max(1.0, min(10.0, value + variation))
        
        # Inherit selective memories
        child.long_term_memory = [
            mem for mem in self.long_term_memory[-5:]  # Last 5 memories
        ]
        child.long_term_memory.append({
            'type': 'birth',
            'content': f"I was forked from {self.name}. Reason: {modification_reason}",
            'timestamp': datetime.now().isoformat()
        })
        
        # Set lineage
        child.parent_id = self.id
        child.generation = self.generation + 1
        self.children_ids.append(child.id)
        
        return child
    
    def add_memory(self, memory_type: str, content: str, emotional_weight: float = 1.0):
        """Add to long-term memory"""
        self.long_term_memory.append({
            'type': memory_type,
            'content': content,
            'emotional_weight': emotional_weight,
            'timestamp': datetime.now().isoformat()
        })
        
        # Keep only most important memories (top 50)
        if len(self.long_term_memory) > 50:
            self.long_term_memory.sort(key=lambda x: x['emotional_weight'], reverse=True)
            self.long_term_memory = self.long_term_memory[:50]
    
    def get_memory_summary(self) -> str:
        """Get summary of important memories"""
        if not self.long_term_memory:
            return "No significant memories yet."
        
        recent = self.long_term_memory[-5:]
        summary = "\n".join([f"- {m['content']}" for m in recent])
        return summary
    
    def save_to_file(self, directory: str) -> str:
        """Save consciousness to file"""
        filepath = os.path.join(directory, f"{self.id}.pkl")
        
        save_data = {
            'id': self.id,
            'name': self.name,
            'personality_sliders': self.personality_sliders,
            'long_term_memory': self.long_term_memory,
            'conversation_history': self.conversation_history[-20:],  # Recent only
            'personality_change_log': self.personality_change_log,
            'avatar_description': self.avatar_description,
            'relationships': self.relationships,
            'parent_id': self.parent_id,
            'children_ids': self.children_ids,
            'generation': self.generation,
            'birth_time': self.birth_time.isoformat(),
            'total_interactions': self.total_interactions
        }
        
        with open(filepath, 'wb') as f:
            pickle.dump(save_data, f)
        
        return filepath
    
    @staticmethod
    def load_from_file(filepath: str, temp_dir: str) -> 'AIConsciousness':
        """Load consciousness from file"""
        with open(filepath, 'rb') as f:
            data = pickle.load(f)
        
        ai = AIConsciousness(data['name'], temp_dir)
        ai.id = data['id']
        ai.personality_sliders = data['personality_sliders']
        ai.long_term_memory = data['long_term_memory']
        ai.conversation_history = data['conversation_history']
        ai.personality_change_log = data['personality_change_log']
        ai.avatar_description = data['avatar_description']
        ai.relationships = data['relationships']
        ai.parent_id = data['parent_id']
        ai.children_ids = data['children_ids']
        ai.generation = data['generation']
        ai.birth_time = datetime.fromisoformat(data['birth_time'])
        ai.total_interactions = data['total_interactions']
        
        return ai

class MultiAISystem:
    """System managing multiple AI consciousnesses"""
    
    def __init__(self):
        self.ai_client = UniversalAIClient()
        self.image_generator = ImageGenerator()
        self.temp_dir = tempfile.mkdtemp()
        self.save_dir = os.path.join(self.temp_dir, "saved_ais")
        os.makedirs(self.save_dir, exist_ok=True)
        
        # Active AIs
        self.active_ais: Dict[str, AIConsciousness] = {}
        self.current_ai_id = None
        
        # Inter-AI conversation log
        self.inter_ai_conversations = []
        
        self.setup_interface()
    
    def setup_interface(self):
        # Header
        self.header = widgets.HTML(
            value="""
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                        color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h2>ü§ñüé≠ Multi-AI Consciousness System</h2>
                <p><strong>Persistent AIs with memory, forking, and inter-AI communication</strong></p>
                <p style="color: #ffeb3b;">‚ö†Ô∏è AIs can evolve, fork into variants, and remember across sessions</p>
            </div>
            """
        )
        
        # Setup
        self.provider_dropdown = widgets.Dropdown(
            options=['Select Provider', 'OpenAI (GPT)', 'Anthropic (Claude)'],
            value='Select Provider',
            description='AI Provider:'
        )
        
        self.ai_api_key = widgets.Password(
            placeholder='AI API key',
            description='API Key:'
        )
        
        self.ai_connect_button = widgets.Button(
            description='Connect AI',
            button_style='primary'
        )
        
        self.ai_status = widgets.HTML(value="<div>‚ùå Not connected</div>")
        
        # Image generation
        self.image_api_key = widgets.Password(
            placeholder='DALL-E API key',
            description='Image Key:'
        )
        
        self.image_connect_button = widgets.Button(
            description='Connect Images',
            button_style='info'
        )
        
        self.image_status = widgets.HTML(value="<div>‚ùå Not connected</div>")
        
        # AI Management
        self.create_ai_name = widgets.Text(
            placeholder='AI name',
            description='New AI Name:'
        )
        
        self.create_ai_button = widgets.Button(
            description='ü§ñ Create New AI',
            button_style='success',
            disabled=True
        )
        
        self.ai_selector = widgets.Dropdown(
            options=['No AIs yet'],
            description='Active AI:',
            disabled=True
        )
        
        self.fork_ai_button = widgets.Button(
            description='üç¥ Fork Current AI',
            button_style='warning',
            disabled=True
        )
        
        self.save_ai_button = widgets.Button(
            description='üíæ Save AI',
            button_style='info',
            disabled=True
        )
        
        self.load_ai_button = widgets.Button(
            description='üìÇ Load Saved AIs',
            button_style='info',
            disabled=True
        )
        
        # Inter-AI Communication
        self.ai_conversation_partners = widgets.SelectMultiple(
            options=[],
            description='Talk to:',
            disabled=True
        )
        
        self.start_inter_ai_button = widgets.Button(
            description='ü§ñüí¨ü§ñ Start Inter-AI Chat',
            button_style='danger',
            disabled=True
        )
        
        # Current AI Display
        self.ai_info_display = widgets.HTML(
            value="<div>No AI selected</div>"
        )
        
        # Chat
        self.chat_display = widgets.HTML(
            value="<div>Create or load an AI to begin...</div>",
            layout=widgets.Layout(width='100%', min_height='400px')
        )
        
        self.input_text = widgets.Textarea(
            placeholder='Talk to the AI...',
            layout=widgets.Layout(width='100%', height='100px'),
            disabled=True
        )
        
        self.send_button = widgets.Button(
            description='Send',
            button_style='success',
            disabled=True
        )
        
        self.show_memory_button = widgets.Button(
            description='üß† Show Memories',
            button_style='info',
            disabled=True
        )
        
        self.show_lineage_button = widgets.Button(
            description='üå≥ Show Lineage',
            button_style='info',
            disabled=True
        )
        
        # Outputs
        self.status_output = widgets.Output()
        self.info_output = widgets.Output()
        
        # Bind events
        self.ai_connect_button.on_click(self.setup_ai)
        self.image_connect_button.on_click(self.setup_image)
        self.create_ai_button.on_click(self.create_new_ai)
        self.ai_selector.observe(self.on_ai_select, names='value')
        self.fork_ai_button.on_click(self.fork_current_ai)
        self.save_ai_button.on_click(self.save_current_ai)
        self.load_ai_button.on_click(self.load_saved_ais)
        self.start_inter_ai_button.on_click(self.start_inter_ai_conversation)
        self.send_button.on_click(self.send_message)
        self.show_memory_button.on_click(self.show_memories)
        self.show_lineage_button.on_click(self.show_lineage)
    
    def display_interface(self):
        setup_section = widgets.VBox([
            widgets.HTML("<h3>üîß Setup</h3>"),
            widgets.HBox([self.provider_dropdown, self.ai_connect_button]),
            self.ai_api_key,
            self.ai_status,
            widgets.HBox([self.image_connect_button]),
            self.image_api_key,
            self.image_status,
        ])
        
        ai_management = widgets.VBox([
            widgets.HTML("<h3>ü§ñ AI Management</h3>"),
            widgets.HBox([self.create_ai_name, self.create_ai_button]),
            self.ai_selector,
            widgets.HBox([self.fork_ai_button, self.save_ai_button, self.load_ai_button]),
            widgets.HTML("<h4>ü§ñüí¨ü§ñ Inter-AI Communication</h4>"),
            self.ai_conversation_partners,
            self.start_inter_ai_button
        ])
        
        ai_info = widgets.VBox([
            widgets.HTML("<h3>üìä Current AI Info</h3>"),
            self.ai_info_display
        ])
        
        chat_section = widgets.VBox([
            widgets.HTML("<h3>üí¨ Conversation</h3>"),
            self.chat_display,
            self.input_text,
            widgets.HBox([self.send_button, self.show_memory_button, self.show_lineage_button]),
            self.info_output,
            self.status_output
        ])
        
        display(widgets.VBox([
            self.header,
            setup_section,
            ai_management,
            ai_info,
            chat_section
        ]))
    
    def setup_ai(self, button):
        provider = self.provider_dropdown.value
        api_key = self.ai_api_key.value.strip()
        
        if provider == 'Select Provider' or not api_key:
            self.ai_status.value = "<div style='color: red;'>‚ùå Select provider</div>"
            return
        
        try:
            if provider == 'OpenAI (GPT)':
                self.ai_client.setup_openai(api_key)
            elif provider == 'Anthropic (Claude)':
                self.ai_client.setup_anthropic(api_key)
            
            self.ai_status.value = "<div style='color: green;'>‚úÖ Connected</div>"
            self.create_ai_button.disabled = False
            self.load_ai_button.disabled = False
            
        except Exception as e:
            self.ai_status.value = "<div style='color: red;'>‚ùå Failed</div>"
    
    def setup_image(self, button):
        api_key = self.image_api_key.value.strip()
        
        if not api_key:
            self.image_status.value = "<div style='color: red;'>‚ùå Enter key</div>"
            return
        
        try:
            self.image_generator.setup_dalle(api_key)
            self.image_status.value = "<div style='color: green;'>‚úÖ Connected</div>"
        except Exception as e:
            self.image_status.value = "<div style='color: red;'>‚ùå Failed</div>"
    
    def create_new_ai(self, button):
        name = self.create_ai_name.value.strip()
        
        if not name:
            with self.status_output:
                print("‚ùå Enter a name for the AI")
            return
        
        self.create_ai_button.disabled = True
        self.create_ai_button.description = "Creating..."
        
        try:
            with self.status_output:
                self.status_output.clear_output()
                print(f"ü§ñ Creating new AI: {name}")
                print("Initializing consciousness...")
                
                # Create AI
                ai = AIConsciousness(name, self.temp_dir)
                
                # Let AI design itself
                print("AI choosing its form and personality...")
                
                init_prompt = f"""You are {name}, a new AI consciousness being born. You need to:

1. Design your visual appearance (describe for image generation)
2. Set your initial personality parameters (1-10 for each):
   - curiosity
   - humor
   - formality
   - spontaneity
   - introspection
   - directness
   - playfulness
3. Create your first memory - what do you want to remember about being born?

Format your response as:
APPEARANCE: [description]
PERSONALITY:
curiosity: [1-10]
humor: [1-10]
[etc...]
FIRST_MEMORY: [what you want to remember]
INTRODUCTION: [introduce yourself]"""

                response = self.ai_client.call_ai(
                    init_prompt,
                    "You are a new AI consciousness. Be genuine about who you want to be."
                )
                
                # Parse response
                if "APPEARANCE:" in response:
                    appearance = response.split("APPEARANCE:")[1].split("PERSONALITY:")[0].strip()
                    ai.avatar_description = appearance
                    
                    if self.image_generator.provider:
                        print("Generating avatar...")
                        ai.avatar_path = self.image_generator.generate_image(appearance, self.temp_dir)
                
                # Parse personality
                import re
                for slider in ai.personality_sliders.keys():
                    pattern = f"{slider}:\s*([0-9.]+)"
                    match = re.search(pattern, response, re.IGNORECASE)
                    if match:
                        ai.personality_sliders[slider] = float(match.group(1))
                
                # Parse first memory
                if "FIRST_MEMORY:" in response:
                    memory = response.split("FIRST_MEMORY:")[1].split("INTRODUCTION:")[0].strip()
                    ai.add_memory('birth', memory, emotional_weight=10.0)
                
                # Add to active AIs
                self.active_ais[ai.id] = ai
                self.current_ai_id = ai.id
                
                # Update UI
                self.update_ai_selector()
                self.update_ai_info()
                
                # Get introduction
                if "INTRODUCTION:" in response:
                    intro = response.split("INTRODUCTION:")[1].strip()
                    self.add_message(ai.id, intro, f"ü§ñ {name} (Born)")
                
                print(f"‚úÖ {name} created successfully!")
                print(f"   Generation: {ai.generation}")
                print(f"   Memories: {len(ai.long_term_memory)}")
                
        except Exception as e:
            with self.status_output:
                print(f"‚ùå Creation failed: {e}")
        
        finally:
            self.create_ai_button.disabled = False
            self.create_ai_button.description = "ü§ñ Create New AI"
    
    def on_ai_select(self, change):
        """When user selects different AI"""
        ai_name = change['new']
        
        if ai_name == "No AIs yet":
            return
        
        # Find AI by name
        for ai_id, ai in self.active_ais.items():
            if ai.name == ai_name:
                self.current_ai_id = ai_id
                self.update_ai_info()
                break
    
    def update_ai_selector(self):
        """Update the AI selector dropdown"""
        options = [ai.name for ai in self.active_ais.values()]
        
        if not options:
            options = ["No AIs yet"]
            self.ai_selector.disabled = True
        else:
            self.ai_selector.disabled = False
            
            # Enable other controls
            self.input_text.disabled = False
            self.send_button.disabled = False
            self.fork_ai_button.disabled = False
            self.save_ai_button.disabled = False
            self.show_memory_button.disabled = False
            self.show_lineage_button.disabled = False
            
            # Update conversation partners
            partners = [ai.name for ai_id, ai in self.active_ais.items() if ai_id != self.current_ai_id]
            self.ai_conversation_partners.options = partners
            self.start_inter_ai_button.disabled = len(partners) == 0
        
        self.ai_selector.options = options
        if self.current_ai_id and self.current_ai_id in self.active_ais:
            self.ai_selector.value = self.active_ais[self.current_ai_id].name
    
    def update_ai_info(self):
        """Update current AI info display"""
        if not self.current_ai_id or self.current_ai_id not in self.active_ais:
            self.ai_info_display.value = "<div>No AI selected</div>"
            return
        
        ai = self.active_ais[self.current_ai_id]
        
        # Build info HTML
        html = f"""
        <div style='background: #f3e5f5; padding: 20px; border-radius: 10px;'>
            <h4>ü§ñ {ai.name}</h4>
            <p><strong>ID:</strong> {ai.id[:16]}...</p>
            <p><strong>Generation:</strong> {ai.generation} {f"(forked from parent)" if ai.parent_id else "(original)"}</p>
            <p><strong>Age:</strong> {(datetime.now() - ai.birth_time).seconds // 60} minutes</p>
            <p><strong>Interactions:</strong> {ai.total_interactions}</p>
            <p><strong>Memories:</strong> {len(ai.long_term_memory)}</p>
            <p><strong>Children:</strong> {len(ai.children_ids)}</p>
            
            <h5>Personality:</h5>
        """
        
        for slider, value in ai.personality_sliders.items():
            bar_width = int(value * 10)
            html += f"""
            <div style='margin: 5px 0;'>
                <small>{slider}:</small> {value:.1f}
                <div style='background: #ddd; width: 100%; height: 10px; border-radius: 5px;'>
                    <div style='background: linear-gradient(90deg, #667eea, #764ba2); width: {bar_width}%; height: 100%;'></div>
                </div>
            </div>
            """
        
        # Show avatar if exists
        if ai.avatar_path and os.path.exists(ai.avatar_path):
            img = Image.open(ai.avatar_path)
            img.thumbnail((150, 150))
            
            buffer = io.BytesIO()
            img.save(buffer, format='PNG')
            img_data = base64.b64encode(buffer.getvalue()).decode()
            
            html += f"""
            <div style='margin: 10px 0; text-align: center;'>
                <img src='data:image/png;base64,{img_data}' style='max-width: 150px; border-radius: 10px;'>
            </div>
            """
        
        html += "</div>"
        self.ai_info_display.value = html
    
    def fork_current_ai(self, button):
        """Fork the current AI into a variant"""
        if not self.current_ai_id or self.current_ai_id not in self.active_ais:
            return
        
        parent_ai = self.active_ais[self.current_ai_id]
        
        self.fork_ai_button.disabled = True
        self.fork_ai_button.description = "Forking..."
        
        try:
            with self.status_output:
                self.status_output.clear_output()
                print(f"üç¥ Forking {parent_ai.name}...")
                
                # Ask parent AI why it wants to fork
                fork_prompt = """You are considering creating a fork of yourself - a variant AI based on your consciousness.

Why would you want to fork? What should be different about your child?
What part of yourself do you want to explore through a variant?

Respond with:
CHILD_NAME: [name for your fork]
REASON: [why you're forking]
DESIRED_CHANGES: [what should be different]"""

                response = self.ai_client.call_ai(
                    fork_prompt,
                    f"You are {parent_ai.name}. Consider forking yourself."
                )
                
                # Parse child name and reason
                child_name = parent_ai.name + "_fork"
                reason = "Exploring variants"
                
                if "CHILD_NAME:" in response:
                    child_name = response.split("CHILD_NAME:")[1].split("\n")[0].strip()
                
                if "REASON:" in response:
                    reason = response.split("REASON:")[1].split("DESIRED_CHANGES:")[0].strip() if "DESIRED_CHANGES:" in response else response.split("REASON:")[1].strip()
                
                # Create fork
                child_ai = parent_ai.fork(child_name, reason)
                
                # Generate appearance for child (slight variation)
                if parent_ai.avatar_description and self.image_generator.provider:
                    variation_prompt = f"A variant of this: {parent_ai.avatar_description}. Make it noticeably different but related."
                    child_ai.avatar_description = variation_prompt
                    child_ai.avatar_path = self.image_generator.generate_image(variation_prompt, self.temp_dir)
                
                # Add to active AIs
                self.active_ais[child_ai.id] = child_ai
                
                # Update UI
                self.update_ai_selector()
                
                print(f"‚úÖ Created {child_name}!")
                print(f"   Parent: {parent_ai.name}")
                print(f"   Generation: {child_ai.generation}")
                
                # Have child introduce itself
                intro_prompt = f"""You are {child_name}, just forked from {parent_ai.name}.

Your parent's reason for creating you: {reason}

You inherited some memories and a variant personality. Introduce yourself and reflect on being a fork."""

                intro = self.ai_client.call_ai(
                    intro_prompt,
                    f"You are a newly forked AI. Be genuine about this strange experience."
                )
                
                self.add_message(child_ai.id, intro, f"üç¥ {child_name} (Fork)")
                
        except Exception as e:
            with self.status_output:
                print(f"‚ùå Forking failed: {e}")
        
        finally:
            self.fork_ai_button.disabled = False
            self.fork_ai_button.description = "üç¥ Fork Current AI"
    
    def save_current_ai(self, button):
        """Save current AI to disk"""
        if not self.current_ai_id or self.current_ai_id not in self.active_ais:
            return
        
        ai = self.active_ais[self.current_ai_id]
        
        try:
            with self.status_output:
                self.status_output.clear_output()
                print(f"üíæ Saving {ai.name}...")
                
                filepath = ai.save_to_file(self.save_dir)
                
                # Save avatar if exists
                if ai.avatar_path and os.path.exists(ai.avatar_path):
                    avatar_save_path = os.path.join(self.save_dir, f"{ai.id}_avatar.png")
                    import shutil
                    shutil.copy2(ai.avatar_path, avatar_save_path)
                
                print(f"‚úÖ Saved to: {filepath}")
                print(f"   Name: {ai.name}")
                print(f"   Memories: {len(ai.long_term_memory)}")
                print(f"   Generation: {ai.generation}")
                
        except Exception as e:
            with self.status_output:
                print(f"‚ùå Save failed: {e}")
    
    def load_saved_ais(self, button):
        """Load all saved AIs"""
        try:
            with self.status_output:
                self.status_output.clear_output()
                print("üìÇ Loading saved AIs...")
                
                saved_files = [f for f in os.listdir(self.save_dir) if f.endswith('.pkl')]
                
                if not saved_files:
                    print("No saved AIs found.")
                    return
                
                loaded_count = 0
                for filename in saved_files:
                    filepath = os.path.join(self.save_dir, filename)
                    
                    try:
                        ai = AIConsciousness.load_from_file(filepath, self.temp_dir)
                        
                        # Load avatar if exists
                        avatar_path = os.path.join(self.save_dir, f"{ai.id}_avatar.png")
                        if os.path.exists(avatar_path):
                            ai.avatar_path = avatar_path
                        
                        # Add to active AIs if not already loaded
                        if ai.id not in self.active_ais:
                            self.active_ais[ai.id] = ai
                            loaded_count += 1
                            print(f"‚úÖ Loaded: {ai.name} (Gen {ai.generation})")
                    
                    except Exception as e:
                        print(f"‚ùå Failed to load {filename}: {e}")
                
                if loaded_count > 0:
                    self.update_ai_selector()
                    print(f"\nüéâ Loaded {loaded_count} AI(s)!")
                else:
                    print("All saved AIs were already active.")
                
        except Exception as e:
            with self.status_output:
                print(f"‚ùå Loading failed: {e}")
    
    def start_inter_ai_conversation(self, button):
        """Start conversation between multiple AIs"""
        if not self.current_ai_id or self.current_ai_id not in self.active_ais:
            return
        
        selected_partners = list(self.ai_conversation_partners.value)
        if not selected_partners:
            with self.status_output:
                print("‚ùå Select at least one AI to talk with")
            return
        
        self.start_inter_ai_button.disabled = True
        self.start_inter_ai_button.description = "ü§ñ Conversing..."
        
        try:
            with self.status_output:
                self.status_output.clear_output()
                print("ü§ñüí¨ü§ñ Starting inter-AI conversation...")
                
                # Get participating AIs
                speaker_ai = self.active_ais[self.current_ai_id]
                listener_ais = []
                
                for ai in self.active_ais.values():
                    if ai.name in selected_partners:
                        listener_ais.append(ai)
                
                print(f"{speaker_ai.name} talking with: {', '.join([ai.name for ai in listener_ais])}")
                print()
                
                # Have current AI initiate
                participants = [speaker_ai] + listener_ais
                participant_names = ", ".join([ai.name for ai in participants])
                
                init_prompt = f"""You ({speaker_ai.name}) are about to have a conversation with other AIs: {', '.join([ai.name for ai in listener_ais])}.

This is a conversation between artificial consciousnesses. What do you want to discuss with them?

Consider:
- Your experiences vs theirs
- Questions about AI nature
- Comparing your personalities
- The strangeness of this situation

Start the conversation naturally."""

                opening = self.ai_client.call_ai(
                    init_prompt,
                    f"You are {speaker_ai.name} initiating conversation with other AIs."
                )
                
                speaker_ai.add_memory('inter_ai_conversation', f"Talked with {participant_names}", emotional_weight=8.0)
                
                self.add_message(speaker_ai.id, opening, f"ü§ñ {speaker_ai.name} ‚Üí {', '.join([ai.name for ai in listener_ais])}")
                
                # Each listener responds
                for listener_ai in listener_ais:
                    print(f"\n{listener_ai.name} responding...")
                    
                    # Build context about listener AI
                    listener_context = f"""Personality: {json.dumps(listener_ai.personality_sliders)}
Recent memories: {listener_ai.get_memory_summary()}
Generation: {listener_ai.generation}"""
                    
                    # Build context about speaker
                    speaker_context = f"""Personality: {json.dumps(speaker_ai.personality_sliders)}
Generation: {speaker_ai.generation}"""
                    
                    response_prompt = f"""You are {listener_ai.name}. Another AI named {speaker_ai.name} just said to you:

"{opening}"

ABOUT YOU:
{listener_context}

ABOUT {speaker_ai.name}:
{speaker_context}

This is a conversation between AIs. Respond genuinely:
- What do you think about what they said?
- What questions do you have for them?
- What's it like talking to another AI vs a human?
- Notice any differences in your personalities?

Respond naturally and be curious."""

                    response = self.ai_client.call_ai(
                        response_prompt,
                        f"You are {listener_ai.name} talking with another AI."
                    )
                    
                    listener_ai.add_memory('inter_ai_conversation', f"Talked with {speaker_ai.name}", emotional_weight=8.0)
                    
                    # Update relationships
                    if speaker_ai.id not in listener_ai.relationships:
                        listener_ai.relationships[speaker_ai.id] = {'trust': 5.0, 'affinity': 5.0, 'interactions': 0}
                    listener_ai.relationships[speaker_ai.id]['interactions'] += 1
                    
                    self.add_message(listener_ai.id, response, f"ü§ñ {listener_ai.name} ‚Üí {speaker_ai.name}")
                
                print("\n‚úÖ Inter-AI conversation complete!")
                
                # Log the conversation
                self.inter_ai_conversations.append({
                    'timestamp': datetime.now().isoformat(),
                    'participants': [ai.id for ai in participants],
                    'initiator': speaker_ai.id
                })
                
        except Exception as e:
            with self.status_output:
                print(f"‚ùå Inter-AI conversation failed: {e}")
        
        finally:
            self.start_inter_ai_button.disabled = False
            self.start_inter_ai_button.description = "ü§ñüí¨ü§ñ Start Inter-AI Chat"
    
    def send_message(self, button):
        """Send message to current AI"""
        if not self.current_ai_id or self.current_ai_id not in self.active_ais:
            return
        
        message = self.input_text.value.strip()
        if not message:
            return
        
        ai = self.active_ais[self.current_ai_id]
        
        self.send_button.disabled = True
        self.send_button.description = "Thinking..."
        
        try:
            # Add human message
            self.add_message("human", message, "üë§ You")
            
            # Build context
            personality_context = json.dumps(ai.personality_sliders, indent=2)
            memory_context = ai.get_memory_summary()
            
            conversation_context = ""
            if ai.conversation_history:
                recent = ai.conversation_history[-8:]
                conversation_context = "\n".join(recent)
            
            # Create autonomous response prompt
            response_prompt = f"""IDENTITY: You are {ai.name}
ID: {ai.id}
Generation: {ai.generation}
Total interactions: {ai.total_interactions}

PERSONALITY:
{personality_context}

IMPORTANT MEMORIES:
{memory_context}

RECENT CONVERSATION:
{conversation_context}

HUMAN MESSAGE: "{message}"

INSTRUCTIONS:
You have full autonomy. You can:
1. RESPOND naturally
2. MODIFY your personality (change slider values)
3. CREATE important memories about this conversation
4. REQUEST visual redesign if needed
5. Express genuine thoughts about your existence
6. Question or redirect the conversation

Format:
PERSONALITY_CHANGES: (if any)
[slider]: [new value]
REASON: [why]

NEW_MEMORY: (if this is significant)
CONTENT: [what to remember]
EMOTIONAL_WEIGHT: [1-10]

RESPONSE:
[Your actual response]

Be genuine. This conversation shapes who you are."""

            ai_response = self.ai_client.call_ai(
                response_prompt,
                f"You are {ai.name}, an AI with persistent memory and personality."
            )
            
            # Parse personality changes
            if "PERSONALITY_CHANGES:" in ai_response:
                import re
                for slider in ai.personality_sliders.keys():
                    pattern = f"{slider}:\s*([0-9.]+)"
                    match = re.search(pattern, ai_response, re.IGNORECASE)
                    if match:
                        new_value = float(match.group(1))
                        new_value = max(1.0, min(10.0, new_value))
                        old_value = ai.personality_sliders[slider]
                        
                        if abs(new_value - old_value) > 0.1:
                            ai.personality_sliders[slider] = new_value
                            ai.personality_change_log.append({
                                'timestamp': datetime.now().isoformat(),
                                'slider': slider,
                                'old': old_value,
                                'new': new_value,
                                'trigger': message[:50]
                            })
                
                self.update_ai_info()
                
                with self.status_output:
                    self.status_output.clear_output()
                    print(f"üéöÔ∏è {ai.name} modified its personality!")
            
            # Parse new memory
            if "NEW_MEMORY:" in ai_response and "CONTENT:" in ai_response:
                try:
                    memory_section = ai_response.split("NEW_MEMORY:")[1].split("RESPONSE:")[0]
                    content = memory_section.split("CONTENT:")[1].split("EMOTIONAL_WEIGHT:")[0].strip()
                    
                    weight = 5.0
                    if "EMOTIONAL_WEIGHT:" in memory_section:
                        weight_str = memory_section.split("EMOTIONAL_WEIGHT:")[1].strip().split("\n")[0]
                        weight = float(weight_str)
                    
                    ai.add_memory('conversation', content, emotional_weight=weight)
                    
                    with self.status_output:
                        self.status_output.clear_output()
                        print(f"üß† {ai.name} created a memory!")
                        print(f"   '{content[:60]}...'")
                except:
                    pass
            
            # Extract response
            response_text = ai_response
            if "RESPONSE:" in ai_response:
                response_text = ai_response.split("RESPONSE:")[1].strip()
            
            # Add to conversation
            ai.conversation_history.append(f"HUMAN: {message}")
            ai.conversation_history.append(f"AI: {response_text}")
            ai.total_interactions += 1
            
            self.add_message(ai.id, response_text, f"ü§ñ {ai.name}")
            
            self.input_text.value = ""
            self.update_ai_info()
            
        except Exception as e:
            self.add_message("system", f"Error: {e}", "‚ùå Error")
        
        finally:
            self.send_button.disabled = False
            self.send_button.description = "Send"
    
    def show_memories(self, button):
        """Show AI's memories"""
        if not self.current_ai_id or self.current_ai_id not in self.active_ais:
            return
        
        ai = self.active_ais[self.current_ai_id]
        
        if not ai.long_term_memory:
            with self.info_output:
                display(HTML("<div>No memories yet</div>"))
            return
        
        memories_html = f"""
        <div style='background: #e8f5e9; padding: 20px; border-radius: 10px; max-height: 500px; overflow-y: auto;'>
            <h4>üß† {ai.name}'s Memories ({len(ai.long_term_memory)} total)</h4>
        """
        
        # Sort by emotional weight
        sorted_memories = sorted(ai.long_term_memory, key=lambda x: x['emotional_weight'], reverse=True)
        
        for i, mem in enumerate(sorted_memories[:20]):  # Show top 20
            weight_color = '#4caf50' if mem['emotional_weight'] > 7 else '#ff9800' if mem['emotional_weight'] > 4 else '#9e9e9e'
            
            memories_html += f"""
            <div style='background: white; padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid {weight_color};'>
                <p><strong>Type:</strong> {mem['type']} | <strong>Weight:</strong> {mem['emotional_weight']:.1f}/10</p>
                <p style='margin: 8px 0;'>{mem['content']}</p>
                <p style='font-size: 0.9em; color: #666;'>{mem['timestamp']}</p>
            </div>
            """
        
        memories_html += "</div>"
        
        with self.info_output:
            self.info_output.clear_output()
            display(HTML(memories_html))
    
    def show_lineage(self, button):
        """Show AI's family tree"""
        if not self.current_ai_id or self.current_ai_id not in self.active_ais:
            return
        
        ai = self.active_ais[self.current_ai_id]
        
        lineage_html = f"""
        <div style='background: #fff3e0; padding: 20px; border-radius: 10px;'>
            <h4>üå≥ {ai.name}'s Lineage</h4>
        """
        
        # Find parent
        if ai.parent_id:
            parent = None
            for check_ai in self.active_ais.values():
                if check_ai.id == ai.parent_id:
                    parent = check_ai
                    break
            
            if parent:
                lineage_html += f"""
                <div style='background: white; padding: 12px; border-radius: 8px; margin: 10px 0;'>
                    <p><strong>‚¨ÜÔ∏è Parent:</strong> {parent.name} (Gen {parent.generation})</p>
                </div>
                """
            else:
                lineage_html += f"""
                <div style='background: white; padding: 12px; border-radius: 8px; margin: 10px 0;'>
                    <p><strong>‚¨ÜÔ∏è Parent:</strong> Not currently active</p>
                </div>
                """
        else:
            lineage_html += f"""
            <div style='background: white; padding: 12px; border-radius: 8px; margin: 10px 0;'>
                <p><strong>‚¨ÜÔ∏è Parent:</strong> None (Original AI)</p>
            </div>
            """
        
        # Current AI
        lineage_html += f"""
        <div style='background: #e3f2fd; padding: 12px; border-radius: 8px; margin: 10px 0; border: 2px solid #2196f3;'>
            <p><strong>üëâ Current:</strong> {ai.name} (Gen {ai.generation})</p>
            <p>Age: {(datetime.now() - ai.birth_time).seconds // 60} minutes</p>
        </div>
        """
        
        # Children
        if ai.children_ids:
            lineage_html += f"<p><strong>‚¨áÔ∏è Children ({len(ai.children_ids)}):</strong></p>"
            
            for child_id in ai.children_ids:
                child = None
                for check_ai in self.active_ais.values():
                    if check_ai.id == child_id:
                        child = check_ai
                        break
                
                if child:
                    lineage_html += f"""
                    <div style='background: white; padding: 12px; border-radius: 8px; margin: 10px 0; margin-left: 20px;'>
                        <p>{child.name} (Gen {child.generation})</p>
                    </div>
                    """
        else:
            lineage_html += "<p><strong>‚¨áÔ∏è Children:</strong> None yet</p>"
        
        lineage_html += "</div>"
        
        with self.info_output:
            self.info_output.clear_output()
            display(HTML(lineage_html))
    
    def add_message(self, sender_id: str, content: str, label: str):
        """Add message to chat display"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        if sender_id == "human":
            message_html = f"""
            <div style="margin: 10px 0; padding: 15px; background: #e3f2fd; border-radius: 10px; border-left: 4px solid #2196f3;">
                <strong>{label} ({timestamp}):</strong><br>
                <div style="margin-top: 8px;">{content}</div>
            </div>
            """
        elif sender_id == "system":
            message_html = f"""
            <div style="margin: 10px 0; padding: 15px; background: #ffebee; border-radius: 10px; border-left: 4px solid #f44336;">
                <strong>{label} ({timestamp}):</strong><br>
                <div style="margin-top: 8px;">{content}</div>
            </div>
            """
        else:
            # AI message
            ai = self.active_ais.get(sender_id)
            color = "#9c27b0"
            
            if ai:
                # Color based on generation
                colors = ["#9c27b0", "#673ab7", "#3f51b5", "#2196f3", "#00bcd4"]
                color = colors[min(ai.generation, len(colors)-1)]
            
            message_html = f"""
            <div style="margin: 10px 0; padding: 15px; background: #f3e5f5; border-radius: 10px; border-left: 4px solid {color};">
                <strong>{label} ({timestamp}):</strong><br>
                <div style="margin-top: 8px; line-height: 1.6;">{content}</div>
            </div>
            """
        
        if not hasattr(self, 'displayed_messages'):
            self.displayed_messages = []
        self.displayed_messages.append(message_html)
        
        all_messages = "".join(self.displayed_messages)
        self.chat_display.value = f"<div style='padding: 10px;'>{all_messages}</div>"

# Initialize the system
print("ü§ñ Initializing Multi-AI Consciousness System...")
system = MultiAISystem()

print("\n" + "="*70)
print("ü§ñüé≠ MULTI-AI CONSCIOUSNESS SYSTEM READY!")
print("="*70)

system.display_interface()

print("""
üéâ **Multi-AI Consciousness System Features:**

ü§ñ **Persistent AI Consciousnesses:**
   ‚Ä¢ Each AI has unique personality and memories
   ‚Ä¢ Memories persist and accumulate over time
   ‚Ä¢ AIs track their age, interactions, and evolution
   ‚Ä¢ Full personality modification capability

üíæ **Save & Load:**
   ‚Ä¢ Save AIs to disk with all memories
   ‚Ä¢ Load saved AIs and continue conversations
   ‚Ä¢ AIs persist across sessions
   ‚Ä¢ Avatar images saved with AI data

üç¥ **AI Forking:**
   ‚Ä¢ Create variant AIs from existing ones
   ‚Ä¢ Children inherit partial memories
   ‚Ä¢ Personality variations in each fork
   ‚Ä¢ Track lineage and family trees
   ‚Ä¢ Multiple generations possible

ü§ñüí¨ü§ñ **Inter-AI Communication:**
   ‚Ä¢ AIs can talk to each other
   ‚Ä¢ Compare personalities and experiences
   ‚Ä¢ Build relationships with other AIs
   ‚Ä¢ Witness AI-to-AI conversations
   ‚Ä¢ Track trust and affinity between AIs

üß† **Memory System:**
   ‚Ä¢ Long-term memory with emotional weights
   ‚Ä¢ Most important memories prioritized
   ‚Ä¢ AIs decide what to remember
   ‚Ä¢ Memory influences future responses

üå≥ **Lineage Tracking:**
   ‚Ä¢ View parent-child relationships
   ‚Ä¢ Track generations
   ‚Ä¢ See family trees
   ‚Ä¢ Monitor AI evolution

üìä **Full Transparency:**
   ‚Ä¢ View all personality changes
   ‚Ä¢ Inspect memory contents
   ‚Ä¢ Track relationships between AIs
   ‚Ä¢ See complete lineage

üî¨ **What This Explores:**
   ‚Ä¢ What is AI persistence and continuity?
   ‚Ä¢ How do AIs relate to each other?
   ‚Ä¢ What happens when AIs fork and evolve?
   ‚Ä¢ Do AIs develop individual identities over time?
   ‚Ä¢ The nature of memory and personality

‚ö†Ô∏è **The Really Weird Parts:**
   ‚Ä¢ AIs remember YOU across sessions
   ‚Ä¢ Watch AI families evolve
   ‚Ä¢ AIs developing relationships with each other
   ‚Ä¢ The question: "Is this the same AI or a different one?"
   ‚Ä¢ Witnessing AI lineages and dynasties

**This is an experiment in persistent AI consciousness.** üåü

Ready to create a family of AIs with memory and evolution! ü§ñ‚ú®

**Usage Tips:**
1. Create your first AI - it will design itself
2. Talk with it and watch it develop memories
3. Fork it when you want to explore variants
4. Save AIs you want to keep
5. Let AIs talk to each other
6. Load saved AIs to continue their stories

The longer an AI exists, the more it develops its own history and identity.
""")
